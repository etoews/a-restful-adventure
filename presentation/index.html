<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>A RESTful Adventure</title>

    <meta name="description" content="A REST workshop that guides participants through the design and implementation of a simple adventure game.">
    <meta name="author" content="Kurt Griffiths and Everett Toews">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">
    <link rel="stylesheet" href="css/custom.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="welcome">
          <h1>A RESTful Adventure</h1>
          <h2><a href="http://rack.to/rest">rack.to/rest</a></h2>
          <p><a href="https://one.rackspace.com/display/Engineering/A+RESTful+Adventure#ARESTfulAdventure-Prerequisites">Prerequisites</a></p>
          <center>
            <table>
              <tbody>
                <tr>
                  <td>Kurt Griffiths</td>
                  <td><a href="https://twitter.com/kgriffs">@kgriffs</a></td>
                </tr>
                <tr>
                  <td>Everett Toews</td>
                  <td><a href="https://twitter.com/everett_toews">@everett_toews</a></td>
                </tr>
              </tbody>
            </table>
          </center>
          <aside class="notes">
            [30 sec]
            <ul>
              <li>Welcome to the RESTful Adventure workshop.</li>
              <li>[introduce the instructors]</li>
              <li>Over the next couple of hours we will take you on a journey through the creative process of designing and implementating a simple adventure game.</li>
              <li>Before we move on, let's make sure everyone can bring up the slides and the code samples.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Goal</h1>
          <h3>Design and Implement</h3>
          <h3>a RESTful API</h3>
        </section>

        <section>
          <p>
            <span class="big">‚ò∫</span>
            <span class="fragment big">+ùì°</span>
            <span class="fragment big">=‚òÅ</span>
          </p>
          <aside class="notes">
            [30 sec]
            <ul>
              <li>You'll learn how to combine a user-oriented perspective with the principles of REST to create elegant web services.</li>
              <li>Web services that are elastic, maintainable and reliable.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Agenda</h1>
          <ol>
            <li><a href="#/rest">REST Fundamentals</a></li>
            <li><a href="#/design">Design the API</a></li>
            <li><a href="#/break">Break</a></li>
            <li><a href="#/impl">Implement the Design</a></li>
            <li><a href="#/conclusion">Conclusion</a></li>
            <li><a href="#/qa">Q &amp; A</a></li>
          </ol>
        </section>

        <section id="rest">
          <h1>REST Fundamentals</h1>
        </section>

        <section>
          <section>
            <img width="400" height="345" src="img/that-word-rest.jpg"/>
            <aside class="notes">

              <ul>
                <li>REST is often misunderstood</li>
              </ul>
            </aside>

          </section>

          <section>
            <img height="345" src="img/eniac.jpg"/>
            <aside class="notes">

              <ul>
                <li>So, before we go any further, we need to rewire our brains a little bit.</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>REST is not</h2>
            <p>
              <span class="fragment">[URL|RPC|CRUD] over </span> HTTP
            </p>
            <aside class="notes">
              <ul>
                <li>REST is not HTTP - HTTP APIs are <em>not</em> inherently RESTful.</li>
                <li>REST is not pretty URLs.</li>
                <li>REST is not RPC over HTTP. We aren't talking about calling remote functions on a server.</li>
                <li>And finally, REST is not simply a way to do CRUD over HTTP.</li>
              </ul>
            </aside>
          </section>
          <section>
            <h2>REST is</h2>
            <p class="fragment">An architectural style for network-based applications</p>
            <p class="fragment">A set of constraints formalized by Roy Fielding</p>
            <p class="fragment">A counterpoint to RPC</p>
            <aside class="notes">
              <ul>
                <li>REST is an architectural <em>style</em> that formalizes the concepts behind the way the web was intended to work. It acts as a guide for designing systems that embody the best characteristics of the web.</li>
                <li>REST was defined by one of the early pioneers of the web, Roy Fielding, in his doctoral dissertation.</li>
                <li>REST avoids the brittleness, scalability, and maintainability problems typical of RPC-based architectures. Rather than thinking about "functions" or "endpoints", as you would in RPC, you think in terms of "resources" and "hypermedia".</li>
              </ul>
            </aside>
          </section>
        </section>

        <section>
          <h2>Constraints</h2>
          <blockquote cite="http://www.brainyquote.com/quotes/quotes/w/waltwhitma136364.html">
            &ldquo;The shallow consider liberty a release from all law, from every constraint. The wise man sees in it, on the contrary, the potent Law of Laws.&rdquo;
          </blockquote>
          <p>- Walt Whitman</p>
          <aside class="notes">
            <ul>
              <li>REST is defined by a set of 6 architectural constraints.</li>
              <li>Taken together, these contraints provide a mold for RESTful applications.</li>
            </ul>
          </aside>
        </section>
        <section>
          <ul class="no-bullets inline-h3">
            <li>üçú Client-Server</li>
            <li class="fragment">üêò Stateless</li>
            <li class="fragment">üì¶ Cache</li>
            <li class="fragment">üéπ Uniform Interface</li>
            <li class="fragment">üîó Layering</li>
            <li class="fragment">üéÆ Code-on-Demand</li>
          </ul>

          <aside class="notes">
            <ul>
              <li>Client-Server: This is all about creating a clear separation of concerns, which affords independent evolution and management between client and server. For example, when I sit down at my local Ramen shop, a server brings me a menu of options. I choose from the list of options and place my order. The server then goes off to interface with the backend kitchen services on my behalf. I don't need to know or care how my food is prepared, just that I get what I ordered in a timely manner.</li>
              <li>Stateless: This doesn't mean that your system has no state, just that there is no state shared between individual requests. Transports are unreliable, so you want to avoid embedding state in them. The client is like an elephant that never forgets; the client is responsible for remembering its own session state, and including that information in every request to the server. If a server goes down, a client should be able to provide its session state to a different server in the pool and get the same answer back as it would have from the failed box. If a client crashes or it's network connection fails, it should be able to pick up later where it left off.</li>
              <li>Cache: The idea here is to stock your goods as close to the consumer as possible, to reduce latency and transportation costs. For example, when I click "buy" on Amazon, the fulfillment system routes my order to the warehouse closest to my home that has my item in stock. Amazon regularly caches popular goods in warehouses as close to the consumer as they can get them. REST provides for caching by constraining systems to explicitly define caching parameters through the uniform interface.</li>
              <li>Uniform Interface: The idea here is to provide a set of ground-rules, an <em>a-priori</em> baseline of syntax and semantics. A pianist can sit down at any piano and know what to do. The mechanisms under the lid can and do vary wildly, but the meaning and layout of the keys remain the same. For REST this means a shared language of identifiers, methods, and media types.</li>
              <li>Layering: This extends Client-Server to create a chain of clients and servers, each exposing the same interface. It's like a recursive function. DNS works like this. When I want to find rackspace.com, I'll usually ask a local DNS server for the address. If the local DNS server doesn't know the IP address for my domain, it will act like a client and query another DNS server for the information, and so on and so forth.</li>
              <li>Code-on-Demand: This is an optional constaint that allows the server to delegate processing to clients when that is more efficient, and to also provide dynamic logic to augment the client's limited abilities to understand and process resources provided by the service. When it comes to the web, this constraint people usually equite code-on-demand to JavaScript, but there isn't any reason why it can't be used in other contexts. For example, game engines typically rely on scripts to orchestrate gameplay. These scripts can be delivered dynamically from the server to the client.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Elements of the Uniform Interface</h2>
        </section>

        <section>
<!--
          <p>[draw a big-picture diagram here, then point out the elements and talk about them briefly]</p>
 -->
          <h3 class="fragment">Components</h3>
          <h3 class="fragment">Connectors</h3>
          <h3 class="fragment">Resources</h3>
          <h3 class="fragment">Representations</h3>
          <h3 class="fragment">Control Data</h3>
          <h3 class="fragment">Hypermedia</h3>

          <aside class="notes">
            <ul>
              <li>REST components categorize individual nodes into various roles, with each role conveying a specific set of expectations. Examples of components include origin servers, user agents, gateways, and proxies.</li>
              <li>REST connectors define the types of actions a node performs, such as caching or acting as a client or server. A given component may implement one or more connectors.</li>
              <li>Resources are client-facing models that map in some way to backend data entities. The mapping can be n-to-n and involve any number of transformations and amalgamations. Each resource is identified by a unique, opaque identifier, typically a URL. REST does not dictate a particular URL schema, although it can be helpful to adopt a human-friendly format, as we'll see later on. It's important to note here that the server has complete ownership of this identifier, which means that the client never constructs it, but simply "copies and pastes" identifiers it recieves from previous requests to the server. This makes it easier to evolve your API without breaking clients.</li>
              <li>Representations are snapshots of a resource at a point in time. A single resource can have multiple representations, such as JSON, PNG, or HTML. These representations are formalized as Internet media types. The client and server perform content negotiation to determine the desired representation.</li>
              <li>Control data is passed along with requests and responses to specify general semantics and to modify the default behavior of connectors. In HTTP, examples of control data include the HTTP method (e.g., GET and POST) and conditional headers, such as If-None-Match.</li>
              <li>Hypermedia is one of the most often ignored aspects of REST. This is ironic, because hypermedia is probably the most important difference between REST and other architectural styles, such as RPC. Rather than relying on brittle endpoint specifications, REST uses hypermedia to identify resources and provide a living web of links that clients traverse in order to change application state. The server may provide different links to the client according to the current state of the system. In this way, REST-based systems can be very flexible, allowing different components of the system to evolve independently.</li>
            </ul>
          </aside>
        </section>

        <section id="design">
          <h1>Design the API</h1>
        </section>

        <section>
          <h1>Before We Proceed</h1>
        </section>

        <section>
          <h1>Your REST != My REST</h1>

          <aside class="notes">
            <ul>
              <li>Keep calm. It's going to be okay. Be flexible.</li>
              <li>Often times a design decision needs to be made</li>
              <li>The important part is being consistent throughout your API</li>
              <li>Think programming style guide</li>
              <li>Examples:</li>
              <ul>
                <li>The way URLs are structured</li>
                <li>JSON resource schema</li>
                <li>Whether or not to use X headers</li>
              </ul>
            </ul>
          </aside>
        </section>

        <section>
          <img src="img/zork.jpg">
        </section>

        <section>
          <h1>Brainstorming</h1>

          <aside class="notes">
            <ul>
              <li>Draw some pictures</li>
              <li>Simple tools like text editors</li>
              <li>Identifying resources</li>
              <li>Typing out a list of URLs</li>
              <li>Mocking up some sample JSON resources</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Lab</h1>
          <h2>Whiteboarding</h2>
        </section>

        <section>
          <h1>Use Cases</h1>

          <aside class="notes">
            <ul>
              <li>Who is your audience?</li>
              <li>Not necessarily designing the API for everyone</li>
              <li>Stick to known use cases without designing yourself into a corner</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Example</h1>
          <p><a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/design/use-cases.md" target="_blank">Safely navigate a dungeon from start to finish</a></p>
        </section>

        <section>
          <h1>Early Technical Decisions</h1>
          <ul>
            <li>Media Types</li>
            <li>IDs vs hypermedia</li>
            <li>Pretty URLs</li>
            <li>Versioning</li>
            <li>Authentication</li>
            <li>Resource Updates</li>
            <li>(State Transitions)</li>
          </ul>

          <aside class="notes">
            <ul>
              <li>Media Types: JSON vs. XML vs. YAML vs. Protocol Buffers. Pick one that meets your requirements. Default to JSON.</li>
              <li>IDs vs hypermedia: I'll just pose a question on this one, how much does thinking of the data model implementation affect design of the API resource model?</li>
              <li>Pretty URLs: This decision has a bigger impact if you're not doing hypermedia. If you're relying on clients to construct the URLs, the prettiness of the URLs matters a lot early on.</li>
              <li>Versioning: Not a solved problem and there's no de facto standard. Put the version in a header, probably the Accept header.</li>
              <li>Auth: Punt</li>
              <li>Resouce Updates: PUT or PATCH or JSON PATCH</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>API Definition</h1>
          <h1>Formats</h1>
          <ul>
            <li>API Blueprint</li>
            <li>RAML</li>
            <li>Swagger</li>
          </ul>

          <aside class="notes">
            <ul>
              <li>When you're ready, it's a way to formalize your thinking</li>
              <li>It's not documentation</li>
              <li>It's the contract between client and server</li>
            </ul>
          </aside>
        </section>

        <section>
          <img src="img/api-definition-contract.png">
          <p>Image Credit: <a href="http://apievangelist.com/2014/12/21/making-sure-the-most-important-layers-of-api-space-stay-open/">Kin Lane</a></p>

          <aside class="notes">
            <ul>
              <li>It drives the implementation of the client</li>
              <li>It drives the implementation of the server</li>
              <li>When it comes to the implementation of the server, there is a huge temptation to have the server generate the API definition from code</li>
              <li>But doing so makes it all too easy to break the API and your clients.</li>
              <li>It's an option if controls are in place to ensure changes to the server code, don't change the API definition unexpectedly, e.g. controls in your CI pipeline</li>
              <li>If you're not generating the API definition, how do you keep the definition and implementation in sync?</li>
              <li>Request/Response validators, test frameworks, </li>
              <li>The point is changes to the API need to be considered carefully and communicated to clients</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Swagger</h1>
          <h2><a href="https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md" target="_blank">Spec</a></h2>

          <aside class="notes">
            <ul>
              <li>Chosen to learn more about it</li>
              <li>YAML and JSON. Built on JSON Schema</li>
              <li>It's certainly not perfect</li>
              <li>The spec can be hard to follow and there aren't examples of everything</li>
              <li>2.0 released late last year and not all of the tooling has caught up</li>
              <li>A bunch of tools for 2.0 were just released last week</li>
              <li>The editor has improved since we began creating this workshop</li>
              <li>Some of the 3rd party tools look like they're in good shape, particularly the Python stuff</li>
              <li>I'd also be very interested to hear from people who've worked with RAML and API Blueprint</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Lab: Paths</h1>
          <pre><code data-trim>
swagger: "2.0"
info:
  version: 1.0.0
  title: A RESTful Adventure
host: localhost
schemes:
  - http
consumes:
  - application/json
produces:
  - application/json
paths:
  /characters:
  ???
          </code></pre>
        </section>

        <section>
          <h1>Lab: Examples</h1>
          <pre><code data-trim>
swagger: "2.0"
info:
  version: 1.0.0
  title: A RESTful Adventure
host: localhost
schemes:
  - http
consumes:
  - application/json
produces:
  - application/json
paths:
  /characters:
    get:
      responses:
        200:
          examples:
            application/json: |-
              {
                "?": "?"
                ...
              }
    post:
      x-examples:
        application/json: { "?": "?" }
      responses:
        201:
          headers:
            Location:
              type: ?
              format: ?
              description: ?
          examples:
            application/json: |-
              {
                "?": "?"
                ...
              }
          </code></pre>
        </section>

        <section>
          <h1>Lab: Models</h1>
          <p>Hint: <a href="https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#data-types" target="_blank">Data Types</a></p>
          <pre><code data-trim>
swagger: "2.0"
info:
  version: 1.0.0
  title: A RESTful Adventure
host: localhost
schemes:
  - http
consumes:
  - application/json
produces:
  - application/json
paths:
  /characters:
  ...
definitions:
  Character:
    type: object
    properties:
      replace-this-with-name-of-property-1:
        type: ?
        format: ?
      replace-this-with-name-of-property-2:
        type: ?
        format: ?
  Characters:
    type: array
    items:
      $ref: "#/definitions/Character"
          </code></pre>
        </section>

        <section>
          <h1>User-Centric</h1>

          <aside class="notes">
            <ul>
              <li>What kind of clients will you support?</li>
              <li>Writing some client code for those URLs</li>
              <li>curl</li>
              <li>mobile</li>
              <li>SDKs</li>
              <li>Writing some mock server code for those URLs</li>
              <li>Flask</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Lab: curl and python -m json.tool</h1>
          <p>Bonus Points: Use <a href="http://httpie.org">httpie</a> and <a href="http://stedolan.github.io/jq/">jq</a> instead</p>
          <pre><code data-trim>
HOST=http://104.130.13.137

echo "Get characters"
curl ? | python -m json.tool

echo "Create a character"
curl ?
          </code></pre>
        </section>

        <section>
          <h1>Example</h1>
          <ul>
            <li>Client: <a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/design/id-based/mock_client.sh" target="_blank">httpie</a></li>
            <li>Server: <a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/design/id-based/mock_server.py" target="_blank">Flask</a></li>
          </ul>
        </section>
        <section>
          <h1>Errors</h1>

          <aside class="notes">
            <ul>
              <li>Good errors can make or break your API</li>
              <li>Take auth for example. It's the first thing developers go through and they always get it wrong the first time. If your error messages are bad, they will walk away and not come back.</li>
              <li>Give developers actionable errors. Include a URL to a web page where they can get more information. Include a team email address where they can get support.</li>
              <li>Include a transaction id for error response. Used to easily match an API user debugging their application to the errors on the server side, as discoverable by the operations team running the API.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Example</h1>

          <pre><code data-trim>
{
  "transaction_id": "71607e7c-df7c-45f3-b571-d1829de4ad9a",
  "code": "736.9",
  "title": "Teleport Denied",
  "description": "The room you tried to visit does not exist or is not accessible from your current room. Thought you could get away with it didn't you.",
  "link": {
      "rel": "help",
      "href": "http://en.wikipedia.org/wiki/No-teleportation_theorem"
    }
}
          </code></pre>
        </section>

        <section>
          <h1>Documentation</h1>

          <aside class="notes">
            <ul>
              <li>APIs should as self documenting as possible</li>
              <li>Should be as machine readable as possible</li>
              <li>There will always be a semantic gap that requires human understanding</li>
              <li>This is where beautiful documentation comes in</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>Lab: API Doc</h1>
          <h2>Copy: <a href="https://raw.githubusercontent.com/everett-toews/a-restful-adventure/gh-pages/design/hypermedia-based/swagger.yaml" target="_blank">Swagger YAML</a></h2>
          <h2>Paste: <a href="http://editor.swagger.io/" target="_blank">Swagger Editor</a></h2>
        </section>

        <section>
          <h1>Final Thoughts</h1>

          <aside class="notes">
            <ul>
              <li>If there's one thing I want you to leave with from the design portion, it's the notion of user-centric design.</li>
              <li>There's lots of ways to go about it but it can be tough when you're on a small team.</li>
              <li>One idea is to totally decouple API design and implementation from API clients and testing.</li>
              <li>Have 1 person come up with the design and implementation.</li>
              <li>Have 1 person come up with the unit tests and clients.</li>
              <li>And the only way you can communicate is through doc and bug reports.</li>
              <li>If at any point the tester/client is looking at server source code, you're doing it wrong.</li>
            </ul>
          </aside>
        </section>

          <section id="break">
          <h1>Break</h1>
          <aside class="notes">
            We're going to now take a short break. In the next module we will be working in python, so please make sure you are ready to go with python installed and your favorite text-editor or IDE. If you need help getting set up, please let one of us know and we'd be glad to help.
          </aside>
        </section>

        <section id="impl">
          <h1>Implement the Design</h1>
          <h2><a href="http://rack.to/rest#impl">rack.to/rest#impl</a></h2>
          <aside class="notes">
            <ul>
              <li>Welcome back! Let's get started.</li>
              <li>During this next module we are going to implement a RESTful web service using python.</li>
              <li>We'll approach this by implementing slices of the API at a time.</li>
              <li>We <em>will</em> need to move quickly, so I'd like to encourage everyone to follow along with the slides in your own browser, and copy-paste the code snippets as we work through the labs.</li>
              <li>Everett will be walking around to help, so please flag him down at any time during the labs if you could use a hand.</li>
            </ul>
          </aside>
        </section>

        <section>
          <h1>The API Spec</h1>
          <p><a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/design/hypermedia-based/swagger.yaml" target="_blank">/design/hypermedia-based/swagger.yaml</a></p>

          <aside class="notes">
            <ul>Here's the design we'll be implementing.</ul>
            <ul>I won't spend much time on it now, but we'll refer back to portions of it as we go along.</ul>
            <ul>I'll explain more along the way.</ul>
            <ul>It probably isn't a perfectly RESTful design, but it is a fairly pragmatic one and showcases some of the more salient design principles of the REST architectural style.</ul>
          </aside>
        </section>

        <section id="impl-lab-1">
          <h1>Lab: Hello world!</h1>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ mkdir restful-adventure
$ cd restful-adventure
$ subl .
          </code></pre>
          <aside class="notes">
            First, let's create a directory for our project and cd into it. If you are using an IDE, you can create a new project within that, but I'm using a combination of the command line and a text editor called Sublime Text, so I'll do it like this:
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ wget http://rack.to/rest-api -O api.py
$ wget http://rack.to/rest-dal -O dal.py
          </code></pre>
          <aside class="notes">
            <p>Now we need to download a skeleton api.py file to your project directory. You can do this through the browser or with wget.</p>
            <p>We also need to download the data access layer module, or DAL, contained in dal.py.</p>
            <p>Now open api.py in your editor. We will be filling this out in a series of labs. See those funny-looking comments with the angle brackets? Those are placeholders that we'll replace with code as we go along. Each placeholder comment has a unique tag that I'll reference.</p>
            <p>All set?</p>
          </aside>
        </section>

        <section>
          <h3>w1</h3>
          <pre><code data-trim class="lang-py">
def application(env, start_response):
    body = 'Hello ' + env['HTTP_X_NAME'] + '\n'

    start_response("200 OK", [('Content-Type', 'text/plain')])
    return [body.encode('utf-8')]

          </code></pre>
          <aside class="notes">
            <p>Next let's get a simple "hello world" app working. Do a search in api.py for the tag *w1*. This function is a simple hello world WSGI application. WSGI is a standard for connecting python applications to any of a number of web servers, such as apache httpd or gunicorn. Headers and other information about each request are passed in through the environment dict. The application sets the status code and headers for the response using the start_response callback, and then returns an iterable containing the response body.</p>

            <p>The Python standard library includes a basic references WSGI server that we will use to self-host our application for our labs. Let's try it out.</p>
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ python api.py
          </code></pre>
          <aside class="notes">
            Let's run api.py. I'm using the command line, but if you are using an IDE, you can run the file directly from there if you like.
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ curl 127.0.0.1:8000 -H 'X-Name: Adventurer'
          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
Hello Adventurer

          </code></pre>
        <aside class="notes">
            <p>Now, open another console tab and type this on the command line.</p>
            <p>[Next fragment]</p>
            <p>
            I'm sure all of you are familiar with curl. It works well enough, but I like to use another tool that's a little friendlier called httpie.
            </p>p
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ pip install httpie
$ http 127.0.0.1:8000 X-Name:Adventurer
          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Content-Length: 11
Content-Type: text/plain
Date: Wed, 18 Feb 2015 19:29:29 GMT
Server: WSGIServer/0.1 Python/2.7.9

Hello Adventurer

          </code></pre>
          <aside class="notes">
            Let's install that real quick and give it a try. Enter this at the command line.
          </aside>
        </section>

        <section>
          <h2>Falcon</h2>
          <div><img class="overlaid" src="img/flight-silhouettes.png" width="400" height="250" /></div>
          <aside class="notes">
            OK, so we've seen what a basic WSGI app looks like. But working directly with WSGI is pretty tedious, so we're going to actually use a lightweight REST framework I developed, called Falcon, to make things easier.
          </aside>
        </section>

        <section>
          <p><a href="http://falconframework.org/">falconframework.org</a></p>
          <pre><code data-trim class="lang-sh">
$ pip install falcon
          </code></pre>
          <aside class="notes">
            <p>Let's install falcon now. Just pip install falcon as shown here.</p>
            <p>We'll only be scratching the surface of the Falcon framework today, but if you're interested, you can visit falconframework.org later to learn more.</p>
          </aside>
        </section>

        <section>
          <h3>w3</h3>
          <pre><code data-trim>
class HelloResource(object):
    def on_get(self, req, resp):
        resp.body = 'Hello ' + req.get_header('x-name') + '\n'
        resp.content_type = 'text/plain'

        # Falcon defaults to 200 OK
        # resp.status = falcon.HTTP_200
          </code></pre>
          <aside class="notes">
            <p>Now let's go back to our app.py file and replace the raw WSGI app with a Falcon app. Find the tag *w4*. Here we define a class to represent a REST resource. It has a single responder method to handle GET requests.</p>

            <p>Note that Falcon defaults to returning 200 OK if you don't specify a status.</p>
          </aside>
        </section>

        <section>
          <h3>w4</h3>
          <pre><code data-trim class="lang-py">
# An instance of falcon.API is a WSGI application
api = falcon.API()
api.add_route('/', HelloResource())
          </code></pre>
          <aside class="notes">
            Next, find the tag *w4*. Here we create an instance of falcon.API and add a route. This route says that if the user agent requests the root path of our API, that will be handled by an instance of HelloResource.
          </aside>
        </section>

        <section>
          <h3>w2</h3>
          <pre><code data-trim class="lang-py">
server = make_server('127.0.0.1', 8000, api)

          </code></pre>
          <aside class="notes">
            <p>Now, scroll down to find the *w2* tag. Replace "application" with "api" so that the server will use our falcon app instead. It will look like this.</p>

            <p>All set? Now let's test our work.</p>
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000 x-name:Adventurer

          </code></pre>
          <aside class="notes">
            <p>If your server is still running from the last test, kill it with ctrl-c and restart it to pick up the changes. Then, in another console, enter this.</p>

            <p>OK, did that work for everyone? Any questions so far?</p>

            <p>Now that you have a feel for how WSGI apps work, let's dive into creating our game! (yay!)</p>

            <p>We'll take this step by step from the player's perspective. We want to keep the end user in mind.</p>
          </aside>
        </section>

        <section id="impl-lab-3">
          <h1>Lab: Choosing a character</h1>
          <aside class="notes">
            The first thing a player needs to do is choose their character. They will have to find out what characters are available, so we'll start with implementing a collection resource to represent a list of characters.

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-yaml">
/characters:
  get:
    summary: List all Characters
    operationId: list_characters
    responses:
      200:
        description: An array of Characters
        schema:
          $ref: "#/definitions/Characters"
        examples:
          application/json: |-
            {
              "characters": [
                {
                  "name": "Knox Thunderbane",
                  "links": [
                    {
                      "rel": "self",
                      "allow": [
                        "GET", "PUT"
                      ],
                      "href": "/characters/1234"
                    },
                    {
                      "rel": "location",
                      "allow": [
                        "GET", "PUT"
                      ],
                      "href": "/characters/1234/location"
                    }
                  ]
                }
              ],
              "links": [
                {
                  "rel": "self",
                  "allow": [
                    "GET", "POST"
                  ],
                  "href": "/characters"
                }
              ]
            }
          </code></pre>
          <aside class="notes">
            Let's remind ourselves what this is supposed to look like. Here's the swagger spec.

          </aside>
        </section>

        <section>
          <h3>w4</h3>
          <pre><code data-trim class="lang-py">
# api.add_route('/', HelloResource())

          </code></pre>
          <aside class="notes">
            <p>OK, so let's go back to app.py to implement this. We'll start by adding a route to a CharacterList resource.</p>

            <p>Find the tag *w4*.</p>

            <p>Go ahead and just comment out that line to remove the test route.</p>

          </aside>
        </section>

        <section>
          <h3>a14</h3>
          <pre><code data-trim class="lang-py">
controller = Controller()
api.add_route('/characters', CharacterList(controller))

          </code></pre>
          <aside class="notes">
            <p>Next, locate the tag *a14*.</p>

            <p>Replace it with a route for the "/characters" path we saw a few moments ago in our swagger spec.</p>

            <p>The CharacterList class takes an instance of controller, which is part of our data access layer. More about that in a minute.</p>

            <p>Good so far?</p>
          </aside>
        </section>

        <section>
          <h3>a7</h3>
          <pre><code data-trim class="lang-py">
def on_get(self, req, resp):
    # Ask the DAL for a list of entities
    # TODO: If an error is raised, convert it to an instance
    #       of falcon.HTTPError
    characters = self._controller.list_characters()

    # Map the entities to the resource
    resource = {
        'characters': [self._entity_to_resource(c) for c in characters],
        'links': [
            {
                'rel': 'self',
                'allow': ['GET', 'POST'],
                'href': '/characters'
            }
        ]
    }

    # Create a JSON representation of the resource
    resp.body = json.dumps(resource, ensure_ascii=False)

    # Falcon defaults to the JSON media type for the content
    # resp.content_type = 'application/json'

    # Falcon defaults to 200 OK
    # resp.status = falcon.HTTP_200

          </code></pre>
          <aside class="notes">
            <p>OK, next let's fill out the CharacterList resource. Search for the *a7* tag.</p>

            <p>We'll modify the on_get responder to look like this.</p>
          </aside>
        </section>

        <section>
          <h3>a1</h3>
          <pre><code data-trim class="lang-py">
def _entity_to_resource(self, character):
    base_href = self._id_to_href(character['id'])
    links = [
        {
            'rel': 'self',
            'allow': [
                'GET', 'PUT'
            ],
            'href': base_href
        },
        {
            'rel': 'location',
            'allow': [
                'GET', 'PUT'
            ],
            'href': base_href + '/location'
        }
    ]

    return {
        'name': character['name'],
        'links': links
    }
          </code></pre>
          <aside class="notes">
            <p>Next, let's implement that _entity_to_resource() method. We'll put it in a base class so that we can reuse the same function later on when we create the individual character resource class.</p>

            <p>Search for the tag *a1*, and replace it with the code shown here.</p>
          </aside>
        </section>

        <section>
          <h3>a2</h3>
          <pre><code data-trim class="lang-py">
def _id_to_href(self, character_id):
    return '/characters/{0}'.format(character_id)

          </code></pre>
          <aside class="notes">
            <p>Then find the tag *a2* and modify the _id_to_href function to look like this.</p>

          </aside>
        </section>

        <section id="impl-checkpoint-3">
          <h3>Checkpoint</h3>
          <h4>
            <a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/code/api-lab-3.py">api-lab-3.py</a>
          </h4>
          <aside class="notes">
            Your api.py file should now look like this.
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000/characters

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sat, 21 Feb 2015 22:52:54 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 258
content-type: application/json; charset=utf-8

{
    "characters": [
        {
            "links": [
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1",
                    "rel": "self"
                },
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1/location",
                    "rel": "location"
                }
            ],
            "name": "Knox Thunderbane"
        }
    ],
    "links": [
        {
            "allow": [
                "GET",
                "POST"
            ],
            "href": "/characters",
            "rel": "self"
        }
    ]
}
          </code></pre>
          <aside class="notes">
            <p>Let's test this out. First, ctrl-c the running script, if needed, and restart it to pick up the changes. Then in your other console, run this.</p>

            <p>Great! Now we can list the characters and choose one.</p>

            <p>But wait. What if we don't *want* to be Knox Thunderbane?</p>
          </aside>
        </section>

        <section id="impl-lab-4">
          <h1>Lab: Adding a new character</h1>
          <aside class="notes">
            <p>Let's give the player a way to create their own character. We'll begin by reviewing the API design.</p>

            <p>Here's the relevant portion... [next slide]</p>
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-yaml tall">

post:
  summary: Create a Character
  operationId: create_character
  parameters:
    - name: body
      in: body
      required: true
      schema:
        properties:
          name:
            type: string
            minLength: 1
            maxLength: 256
  x-examples:
    application/json: { "name": "Knox Thunderbane" }
  responses:
    201:
      description: Character created
      headers:
        Location:
          type: string
          format: url
          description: A link to the Character
      schema:
        $ref: "#/definitions/Character"
      examples:
        application/json: |-
          {
            "name": "Knox Thunderbane",
            "links": [
              {
                "rel": "self",
                "allow": [
                  "GET", "PUT"
                ],
                "href": "/characters/1234"
              },
              {
                "rel": "location",
                "allow": [
                  "GET", "PUT"
                ],
                "href": "/characters/1234/location"
              }
            ]
          }
    default:
      description: Unexpected errors
      schema:
        $ref: "#/definitions/Error"

          </code></pre>
          <aside class="notes">

          </aside>
        </section>

        <section>
          <h3>a8</h3>
          <pre><code data-trim class="lang-py">
def on_post(self, req, resp):
    # Parse the incoming representation. This can be factored out into
    # Falcon hooks or middleware, but we'll keep it inline for now.
    # TODO: Validate against a schema
    representation = req.stream.read().decode('utf-8')
    representation = json.loads(representation)

    # Create a new entity from the representation
    # TODO: If an error is raised, convert it to an instance
    #       of falcon.HTTPError
    character = self._controller.add_character(representation['name'])

    # Map the entity to the resource. Again, this sort of thing
    # could be factored out into a Falcon hook (DRY).
    resource = self._entity_to_resource(character)

    resp.location = self._id_to_href(character['id'])
    resp.body = json.dumps(resource, ensure_ascii=False)

          </code></pre>
          <aside class="notes">
            OK, so let's go back to our api.py file and add a responder to handle that POST request. We'll implement the on_post method in the CharacterList class. Find the tag *a8* in api.py and update the on_post method to look like this:
          </aside>
        </section>

        <section id="impl-checkpoint-4">
          <h3>Checkpoint</h3>
          <h4>
            <a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/code/api-lab-4.py">api-lab-4.py</a>
          </h4>

          <aside class="notes">
            Now your api.py file should look like this.
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http OPTIONS 127.0.0.1:8000/characters

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 204 No Content
Content-Length: 0
Date: Sat, 21 Feb 2015 22:59:18 GMT
Server: WSGIServer/0.1 Python/2.7.9
allow: GET, POST
          </code></pre>
          <aside class="notes">
            <p>Let's take this for a spin. First, ctrl-c the running script, if needed, and restart it.</p>

            <p>Then in your other console, enter this at the command line to make sure everything is wired up correctly.</p>

            <p>As you can see, the Falcon framework knows which methods the resource supports, and responds with the correct Allow header.</p>

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http POST 127.0.0.1:8000/characters name="Commander Keen"

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sat, 21 Feb 2015 23:00:02 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 254
content-type: application/json; charset=utf-8
location: /characters/8713e99b-d4d2-4855-85a2-9d0a32fec0b7

{
    "links": [
        {
            "allow": [
                "GET",
                "PUT"
            ],
            "href": "/characters/8713e99b-d4d2-4855-85a2-9d0a32fec0b7",
            "rel": "self"
        },
        {
            "allow": [
                "GET",
                "PUT"
            ],
            "href": "/characters/8713e99b-d4d2-4855-85a2-9d0a32fec0b7/location",
            "rel": "location"
        }
    ],
    "name": "Commander Keen"
}
          </code></pre>
          <aside class="notes">
            Now let's add a new character. We'll post a JSON document with a name field to the character list resource like so:
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000/characters

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sat, 21 Feb 2015 23:00:58 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 514
content-type: application/json; charset=utf-8

{
    "characters": [
        {
            "links": [
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1",
                    "rel": "self"
                },
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1/location",
                    "rel": "location"
                }
            ],
            "name": "Knox Thunderbane"
        },
        {
            "links": [
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/13742b78-be28-4662-b379-c9bba55b476c",
                    "rel": "self"
                },
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/13742b78-be28-4662-b379-c9bba55b476c/location",
                    "rel": "location"
                }
            ],
            "name": "Commander Keen"
        }
    ],
    "links": [
        {
            "allow": [
                "GET",
                "POST"
            ],
            "href": "/characters",
            "rel": "self"
        }
    ]
}
          </code></pre>
          <aside class="notes">
<p>And for good measure, let's make sure Commander Keen got added to the list. Run this to list the game characters again.</p>

<p>[next fragment]</p>

<p>Great! Looks like we're in business.</p>
          </aside>
        </section>

        <section id="impl-lab-5">
          <h1>Lab: Choosing a dungeon</h1>
          <aside class="notes">
Now that we can choose a character, or create a new one if we don't like any of the choices, we need to pick a dungeon to play. We want to provide the user agent a set of choices that it can display to the player.
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-yaml tall">
/dungeons:
  get:
    summary: List all Dungeons
    operationId: list_dungeons
    responses:
      200:
        description: An array of Dungeons
        schema:
          $ref: "#/definitions/Dungeons"
        examples:
          application/json: |-
            {
              "dungeons": [
                {
                  "name": "Dungeon of Doom",
                  "links": [
                    {
                      "rel": "self",
                      "allow": [
                          "GET"
                      ],
                      "href": "/dungeons/1234"
                    },
                    {
                      "rel": "room first",
                      "allow": [
                          "GET"
                      ],
                      "href": "/dungeons/1234/rooms/1002",
                      "description": "entrance"
                  ]
                }
              ],
              "links": [
                {
                  "rel": "self",
                  "allow": [
                      "GET"
                  ],
                  "href": "/dungeons"
                }
              ]
            }
          </code></pre>
          <aside class="notes">
<p>Here's the relevant part of our spec.</p>

<p>The implementation is going to look similar to what we did to list characters.</p>
          </aside>
        </section>

        <section>
          <h3>a13</h3>
          <pre><code data-trim class="lang-py">
def on_get(self, req, resp):
    # Ask the DAL for a list of entities
    dungeons = self._controller.list_dungeons()

    # Map the entities to the resource
    resource = {
        'dungeons': [self._entity_to_resource(d) for d in dungeons],
        'links': [
            {
                'rel': 'self',
                'allow': ['GET'],
                'href': '/dungeons'
            }
        ]
    }

    # Create a JSON representation of the resource
    resp.body = json.dumps(resource, ensure_ascii=False)

          </code></pre>
          <aside class="notes">
<p>First, search for the tag *a13*.</p>

<p>When the UA sends us a GET request, we need to return a JSON representation of the list of dungeons in the game.</p>

<p>Update the on_get responder to look like this.</p>
          </aside>
        </section>

        <section>
          <h3>a12</h3>
          <pre><code data-trim class="lang-py">
def _entity_to_resource(self, dungeon):
    base_href = '/dungeons/{0}'.format(dungeon['id'])
    links = [
        {
            'rel': 'self',
            'allow': ['GET'],
            'href': base_href
        },
        {
            'rel': 'room first',
            'allow': [
                'GET', 'PUT'
            ],
            'href': '{0}/rooms/{1}'.format(base_href, dungeon['entry_id'])
        }
    ]

    return {
        'name': dungeon['name'],
        'links': links
    }
          </code></pre>
          <aside class="notes">
Next let's implement that _entity_to_resource helper method. Find the tag *a12* and update the method to look like this:
          </aside>
        </section>

        <section>
          <h3>a17</h3>
          <pre><code data-trim class="lang-py">
api.add_route('/dungeons', DungeonList(controller))

          </code></pre>
          <aside class="notes">
<p>OK, now we need to wire up the resource to a route. Find the tag *a17* and replace it with this line of code.</p>

<p>OK, so now we have our frontend taken care of.</p>
          </aside>
        </section>

        <section id="impl-checkpoint-5">
          <h3>Checkpoint</h3>
          <h4>
            <a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/code/api-lab-5.py">api-lab-5.py</a>
          </h4>

          <aside class="notes">
            At this point your code should look like this file.
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000/dungeons

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sun, 22 Feb 2015 02:13:32 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 564
content-type: application/json; charset=utf-8

{
    "dungeons": [
        {
            "links": [
                {
                    "allow": [
                        "GET"
                    ],
                    "href": "/dungeons/f2e557e6-6b07-417b-b416-17d693f3eadd",
                    "rel": "self"
                },
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/dungeons/f2e557e6-6b07-417b-b416-17d693f3eadd/rooms/29cf865c-936e-4dec-8626-9bab41ea619f",
                    "rel": "room first"
                }
            ],
            "name": "Dungeon of Hope"
        },
        {
            "links": [
                {
                    "allow": [
                        "GET"
                    ],
                    "href": "/dungeons/5a024cd8-2db3-446e-b777-bdc60185a117",
                    "rel": "self"
                },
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/dungeons/5a024cd8-2db3-446e-b777-bdc60185a117/rooms/8f726efc-5e3e-4332-ab24-243a1d3e0b27",
                    "rel": "room first"
                }
            ],
            "name": "Dungeon of Doom"
        }
    ],
    "links": [
        {
            "allow": [
                "GET"
            ],
            "href": "/dungeons",
            "rel": "self"
        }
    ]
}
          </code></pre>
          <aside class="notes">
<p>ctrl-c your app and restart it. Then in your other console window, enter the command shown here.</p>

<p>Cool. So far we've given players the ability to choose a character to play and a dungeon to enter. What's next?</p>
          </aside>
        </section>

        <section>
          <h1>Lab: Entering the dungeon</h1>
          <aside class="notes">
<p>We need to move our character to the dungeon entrance.</p>

<p>Let's remind ourselves what the characters representation looks like.</p>
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000/characters

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sun, 22 Feb 2015 02:32:23 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 258
content-type: application/json; charset=utf-8

{
    "characters": [
        {
            "links": [
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1",
                    "rel": "self"
                },
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1/location",
                    "rel": "location"
                }
            ],
            "name": "Knox Thunderbane"
        }
    ],
    "links": [
        {
            "allow": [
                "GET",
                "POST"
            ],
            "href": "/characters",
            "rel": "self"
        }
    ]
}
          </code></pre>
          <aside class="notes">
<p>Enter this in your console to list the characters...</p>

<p>[next fragment]</p>

<p>Any user agent (UA) can take this list, present it to the player and let them make a choice. In this case, there's just one to choose, so we'll just assume the player picks Knox. The UA then remembers Knox as part of its session data.</p>

<p>Next, the UA queries the link to the dungeon list resource, and presents the results to the player to make a selection. Once the player chooses a dungeon, the UA has all the information it needs to move the character to the dungeon entrance room.</p>

<p>We'll represent this state transition in our API by linking the character's current location to the dungeon's entrance room. The user agent does this by PUTing the link it obtained from the dungeon resource to the location link specified in the character resource.</p>

<p>Let's see how this works.</p>
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ CHAR_LOCATION_URL=/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1/location

          </code></pre>
          <aside class="notes">
First, we'll copy and paste the href from the location link we got in our previous query.

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ ROOM_URL=/dungeons/5a024cd8-2db3-446e-b777-bdc60185a117/rooms/8f726efc-5e3e-4332-ab24-243a1d3e0b27

          </code></pre>
          <aside class="notes">
<p>Next let's copy and paste the href from the Dungeon of Doom's entrance room link. Remember, that's the link with the "room first" relation.</p>

<p>Got it?</p>
          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http PUT 127.0.0.1:8000$CHAR_LOCATION_URL rel=room href=$ROOM_URL

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 404 OK
Date: Fri, 20 Feb 2015 18:45:24 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 0

          </code></pre>
          <aside class="notes">
<p>OK. Now let's link the character to the dungeon entrance room. We will PUT a JSON representation of a link with a "room" relation type, and an href to identify the entrace room. This representation will update the character's location resource so that it points to the Dungeon of Doom's entrance.</p>

<p>So let's try this. Enter the following at the command line.</p>

<p>[next fragment]</p>

<p>OK, we got a 404. That's because Falcon knows we haven't set up a room location resource. Let's go ahead and take care of that next.</p>

<!-- TODO: This could use a graphic to illustrate the point. -->
          </aside>
        </section>

        <section>
          <h3>a6</h3>
          <pre><code data-trim class="lang-py">
def on_put(self, req, resp, character_id):
    # TODO: Validate against a schema
    representation = req.stream.read().decode('utf-8')
    representation = json.loads(representation)

    # TODO: Raise falcon.HTTPError if ID is not a UUID
    character_id = uuid.UUID(character_id)

    # TODO: Raise falcon.HTTPError if ID is not a UUID
    room_href = representation['href']
    room_id = self._room_href_to_id(room_href)

    # TODO: If an error is raised, convert it to an instance
    #       of falcon.HTTPError
    self._controller.move_character(character_id, room_id)

    # Success!
    resp.status = falcon.HTTP_204
          </code></pre>
          <aside class="notes">
Bring up your api.py code again, and search for the tag *a6*. Update the CharacterLocation class's on_put method to look like this:

          </aside>
        </section>

        <section>
          <h3>a5</h3>
          <pre><code data-trim class="lang-py">
def on_get(self, req, resp, character_id):
    # TODO: Handle the case that character_id is not a valid UUID
    character_id = uuid.UUID(character_id)

    # TODO: If an error is raised, convert it to an instance
    #       of falcon.HTTPError
    room_id, dungeon_id = self._controller.get_location(character_id)

    # Define the resource. We have to translate the DAL's notion
    # of a "location" to the API's concept of a "location".
    # TODO: If an error is raised, convert it to an instance
    #       of falcon.HTTPError
    resource = self._room_id_to_location(room_id, dungeon_id)

    # Create a JSON representation of the resource
    # TODO: Use functools.partial to create a version of json.dumps that
    #       defaults to ensure_ascii=False
    resp.body = json.dumps(resource, ensure_ascii=False)

          </code></pre>
          <aside class="notes">
Let's also provide a way to query the location state, so that we can verity our PUT is working. Find the tag *a5* and update the on_get method to look like this:

          </aside>
        </section>

        <section>
          <h3>a3</h3>
          <pre><code data-trim class="lang-py">
def _room_href_to_id(self, href):
    # ID will be the last part of the URL.
    return uuid.UUID(href.split('/')[-1])

          </code></pre>
          <aside class="notes">
Now let's define the self._room_href_to_id() and self._room_id_to_location() methods. Find the tag *a3* and update the code there to look like this:

          </aside>
        </section>

        <section>
          <h3>a4</h3>
          <pre><code data-trim class="lang-py">
def _room_id_to_location(self, room_id, dungeon_id):
    return {
        'rel': 'room',
        'allow': ['GET'],
        'href': 'dungeons/{0}/rooms/{1}'.format(dungeon_id, room_id)
    }

          </code></pre>
          <aside class="notes">
Then, right below that, replace the tag *a4* like so.

          </aside>
        </section>

        <section>
          <h3>a15</h3>
          <pre><code data-trim class="lang-py">
api.add_route('/characters/{character_id}/location', CharacterLocation(controller))
          </code></pre>
          <aside class="notes">
<p>Finally, we need to tell Falcon about our CharacterLocation resource. Find the tag *a15* and replace it with the following call to add_route:</p>

<p>All set?</p>
          </aside>
        </section>

        <section id="impl-checkpoint-6">
          <h3>Checkpoint</h3>
          <h4>
            <a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/code/api-lab-6.py">api-lab-6.py</a>
          </h4>          <aside class="notes">
At this point your api.py file should look like this.

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http PUT 127.0.0.1:8000$CHAR_LOCATION_URL rel=room href=$ROOM_URL

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 204 No Content
Content-Length: 0
Date: Sun, 22 Feb 2015 03:35:06 GMT
Server: WSGIServer/0.1 Python/2.7.9
          </code></pre>
          <aside class="notes">
OK, let's try again to move the character to the dungeon entrance. Restart your app, then in another console run this command.

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000$CHAR_LOCATION_URL

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sun, 22 Feb 2015 03:36:20 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 133
content-type: application/json; charset=utf-8

{
    "allow": [
        "GET"
    ],
    "href": "dungeons/5a024cd8-2db3-446e-b777-bdc60185a117/rooms/8f726efc-5e3e-4332-ab24-243a1d3e0b27",
    "rel": "room"
}
          </code></pre>
          <aside class="notes">
<p>That seemed to work, but let's make sure. Run this to read back the character's location.</p>

<p>[next fragment]</p>

<p>Success! We're on our way!</p>
          </aside>
        </section>

        <section id="impl-lab-7">
          <h1>Lab: Find a way out!</h1>
          <h3>(Preferably without dying...)</h3>
          <aside class="notes">
Now that we've entered the dungeon, we need to traverse the rooms in search of the exit.

          </aside>
        </section>

        <section>
          <ol>
            <li>Dereference the room link for the character's current location to get a list of doorways.</li>
            <li>Present the list of doorways to the player, and let them to choose one.</li>
            <li>Move the character to the chosen room.</li>
            <li>Are we at the exit? If not, go to (1).</li>
          </ol>
          <aside class="notes">
            The User Agent will follow these steps.
          </aside>
        </section>

        <section>
          <h3>Step 1: Get a list of doorways</h3>
          <aside class="notes">
To get a list of doorways, we need to implement a Room resource that will provide a list of links to other rooms. Each of these links represent a doorway out of the room.
          </aside>
        </section>

        <section>
          <p>TODO: description vs. rel - html-ish approach, may be a better way, but I went with this for the impl - maybe make array... could probably change it if necessary...</p>
          <pre><code data-trim class="lang-yaml tall">
/dungeons/{dungeon_id}/rooms/{room_id}:
  get:
    summary: Get a specific Room in a specific Dungeon
    operationId: get_room
    parameters:
      - name: dungeon_id
        in: path
        description: The id of the Dungeon
        required: true
        type: string
      - name: room_id
        in: path
        description: The id of the Room
        required: true
        type: string
    responses:
      200:
        description: Expected response to a valid request
        schema:
          $ref: "#/definitions/Room"
        examples:
          application/json: |-
            {
              "name": "Entrance",
              "is_exit": false,
              "links": [
                {
                  "rel": "self",
                  "href": "/dungeons/1234/rooms/1000"
                },
                {
                  "rel": "room east",
                  "allow": [
                      "GET"
                  ],
                  "href": "/dungeons/1234/rooms/1001"
                }
              ]
            }
      400:
        description: You tried to teleport. That's just not allowed.
        schema:
          $ref: "#/definitions/Error"
        examples:
          application/json: |-
            {
              "transaction_id": "71607e7c-df7c-45f3-b571-d1829de4ad9a",
              "code": "736.9",
              "title": "Teleport Denied",
              "description": "The room you tried to visit does not exist or is not accessible from your current room. Thought you could get away with it didn't you.",
              "link": {
                  "rel": "help",
                  "href": "http://en.wikipedia.org/wiki/No-teleportation_theorem"
                }
            }
      default:
        description: Unexpected errors
        schema:
          $ref: "#/definitions/Error"

          </code></pre>
          <aside class="notes">
<p>Let's look at our spec to remind ourselves how these doorway links work:</p>

<p>OK, so we need to implement a Room resource that can return a JSON representation like the example given in this spec.</p>

<p>Let's go back to our api.py file.</p>
          </aside>
        </section>

        <section>
          <h3>a11</h3>
          <pre><code data-trim class="lang-py">
def on_get(self, req, resp, dungeon_id, room_id):
    # TODO: Handle the case that these are not valid UUIDs
    dungeon_id = uuid.UUID(dungeon_id)
    room_id = uuid.UUID(room_id)

    # Note that we don't actually need the dungeon_id, since
    # the DAL just wants the room_id. We'll just ignore it
    # for now.

    # TODO: If an error is raised, convert it to an instance
    #       of falcon.HTTPError
    room = self._controller.get_room(room_id)

    # Create a resource based on the room entity
    # TODO: If an error is raised, convert it to an instance
    #       of falcon.HTTPError
    resource = self._entity_to_resource(room)

    # Create a JSON representation of the resource
    resp.body = json.dumps(resource, ensure_ascii=False)

          </code></pre>
          <aside class="notes">
<p>Find the tag *a11*.</p>

<p>Update the on_get responder to look like this.</p>

          </aside>
        </section>

        <section>
          <h3>a9, a10</h3>
          <pre><code data-trim class="lang-py">
def _entity_to_resource(self, room):
    dungeon_id = room['dungeon_id']
    room_id = room['id']

    base_href = 'dungeons/{0}'.format(dungeon_id)

    links = [
        {
            'rel': 'self',
            'allow': ['GET'],
            'href': '{0}/rooms/{1}'.format(base_href, room_id)
        },
        {
            'rel': 'dungeon',
            'allow': ['GET'],
            'href': base_href
        }
    ]

    # Add additional links, one per doorway to another room
    links.extend([
        {
            'rel': 'room ' + doorway['direction'],
            'allow': ['GET'],
            'href': self._id_to_href(doorway['room_id'], dungeon_id)
        }

        for doorway in room['doorways']
    ])

    return {
        'name': room['name'],
        'is_exit': room['is_exit'],
        'links': links
    }

def _id_to_href(self, room_id, dungeon_id):
    return '/dungeons/{0}/rooms/{1}'.format(dungeon_id, room_id)

          </code></pre>
          <aside class="notes">
Next, fill in tags *a9* and *a10* as show here, to make self._entity_to_resource() work as it should.

          </aside>
        </section>

       <section>
          <h3>a16</h3>
          <pre><code data-trim class="lang-py">
api.add_route('/dungeons/{dungeon_id}/rooms/{room_id}', Room(controller))

          </code></pre>
          <aside class="notes">
<p>Finally, we just need to add a route to the Room resource. Find the tag *a16*.</p>

<p>Replace it with this call to add_route.</p>
          </aside>
        </section>

        <section id="impl-checkpoint-7">
          <h3>Checkpoint</h3>
          <h4>
            <a href="https://github.com/everett-toews/a-restful-adventure/blob/gh-pages/code/api-lab-7.py">api-lab-7.py</a>
          </h4>
          <aside class="notes">
<p>Before we move on, ctrl-c and restart your WSGI server to pick up the changes we just made.</p>

<p>Let's list the doorways in the entrance room.</p>

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ ROOM_URL=/dungeons/5a024cd8-2db3-446e-b777-bdc60185a117/rooms/751d5812-144d-40f8-a82d-221dbb3075e2

          </code></pre>
          <aside class="notes">
Let's choose the north doorway out of the entrance room. We'll copy and paste the href from that link relation. Go back to your console and paste this on the command line.

          </aside>
        </section>

        <section>
          <h3>Step 3: Move the character</h3>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$  http PUT 127.0.0.1:8000$CHAR_LOCATION_URL rel=room href=$ROOM_URL

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 204 No Content
Content-Length: 0
Date: Sun, 22 Feb 2015 03:56:54 GMT
Server: WSGIServer/0.1 Python/2.7.9

          </code></pre>
          <aside class="notes">
Now let's move the character by linking their location to the room we've chosen to enter. Here's the command.

          </aside>
        </section>

        <section>
          <h3>Are we at the exit? If not, go to (2)</h3>
        </section>


        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000$ROOM_URL

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sun, 22 Feb 2015 03:58:01 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 417
content-type: application/json; charset=utf-8

{
    "is_exit": false,
    "links": [
        {
            "allow": [
                "GET"
            ],
            "href": "dungeons/5a024cd8-2db3-446e-b777-bdc60185a117/rooms/751d5812-144d-40f8-a82d-221dbb3075e2",
            "rel": "self"
        },
        {
            "allow": [
                "GET"
            ],
            "href": "dungeons/5a024cd8-2db3-446e-b777-bdc60185a117",
            "rel": "dungeon"
        },
        {
            "allow": [
                "GET"
            ],
            "href": "/dungeons/5a024cd8-2db3-446e-b777-bdc60185a117/rooms/8f726efc-5e3e-4332-ab24-243a1d3e0b27",
            "rel": "room south"
        }
    ],
    "name": "Armory"
}
          </code></pre>
          <aside class="notes">
<p>Let's see what we can find out about this new room. Here's the command.</p>

<p>[next fragment]</p>

<p>Darn! It's a dead end! The only way out is back the way we just came, so we'll have to backtrack.</p>

<p>So you get the idea. You would continue repeating this process, exploring the dungeon one room at a time until you reach the exit. If you temporarily lose your network connection, or simply get tired and want to take a break, the user agent will still remember the character you were playing with last, and can GET it's last location from the server when you are ready to pick up again where you left off.</p>

          </aside>
        </section>

        <section id="impl-lab-8">
          <h1>Lab: Independent evolution</h1>
          <aside class="notes">
<p>Can you imagine a world in which each time you made a change to your website, everyone had to update their web browsers to a new version? The REST architectural style makes it possible for clients and servers to be more loosely coupled, so that each node on the network can evolve more or less independently over time.</p>

<p>Granted, sometimes a big change can only be made in an incompatible way. However, our goal as API and client developers is to minimize the number of times this has to happen, while still allowing for agile iteration and evolution on both sides.</p>

<p>Now, during our RESTful adventure we saw how we can use hypermedia to change the state of the game. This is one example of how REST can help decouple different parts of a system.</p>

<p>Since the UA is just following links around, it is easier to evolve the server independently of the UA. Changing something in the server is less likely to break the UA, because the UA is making fewer assumptions.</p>

<p>Let's see an example of this real quick.</p>

<p>Suppose we were to change our URL schema for some reason.</p>
          </aside>
        </section>

        <section>
          <h3>/location &nbsp; ‚ûü &nbsp; /foo</h3>
          <aside class="notes">
Go back to your api.py file and find-and-replace all instances of the string '/location' with the string '/foo'. There should be only two instances.

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ http 127.0.0.1:8000/characters

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
HTTP/1.0 200 OK
Date: Sun, 22 Feb 2015 04:21:58 GMT
Server: WSGIServer/0.1 Python/2.7.9
content-length: 258
content-type: application/json; charset=utf-8

{
    "characters": [
        {
            "links": [
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1",
                    "rel": "self"
                },
                {
                    "allow": [
                        "GET",
                        "PUT"
                    ],
                    "href": "/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1/location",
                    "rel": "location"
                }
            ],
            "name": "Knox Thunderbane"
        }
    ],
    "links": [
        {
            "allow": [
                "GET",
                "POST"
            ],
            "href": "/characters",
            "rel": "self"
        }
    ]
}
          </code></pre>
          <aside class="notes">
Restart the WSGI app, and then in another console list the characters:

          </aside>
        </section>

        <section>
          <pre><code data-trim class="lang-sh">
$ CHAR_LOCATION_URL=/characters/c1a008bc-105f-4793-bfa6-a54fbc9ce6b1/foo

          </code></pre>
          <pre class="fragment"><code data-trim class="lang-sh">
$ http PUT 127.0.0.1:8000$CHAR_LOCATION_URL rel=room href=$ROOM_URL

          </code></pre>
          <aside class="notes">
<p>The user agent would then simply copy-paste the location href as before.</p>

<p>[next fragment]</p>

<p>And then proceed to move the character around exactly as before.</p>

<p>Note how the user agent didn't have to change its logic at all to handle the URL schema change. This is just one example of how REST allows clients and servers to evolve independently.</p>

          </aside>
        </section>

        <section id="conclusion">
          <h1>Conclusion</h1>
        </section>

        <section>
          <h1>Add slides about conclusion here</h1>
        </section>

        <section>
          <h1>Rackspace API Working Group</h1>
        </section>

        <section id="qa">
          <h1>Thanks!</h1>
          <h2>Q &amp; A</h2>
          <p><a href="http://rack.to/2015-workshops-feedback" target="_blank">rack.to/2015-workshops-feedback</a></p>
        </section>
      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: false,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
